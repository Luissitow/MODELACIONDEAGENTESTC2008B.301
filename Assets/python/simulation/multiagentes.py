# -*- coding: utf-8 -*-
"""multiagentes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_eclcc055q1YK98sAmTLZjoeRUbpTjSG

# Clase grid
Esta clase sera nuestro model del tablero
https://www.notion.so/Multi-agentes-2a78ec6eea9780dba33cc33ec723cc03

## Importaciones / herramientas
"""

#!pip install numpy scipy matplotlib seaborn scikit-learn mesa -q

import numpy as np
from mesa import Agent, Model
from mesa.space import MultiGrid
from typing import Optional, Tuple
import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
import heapq
import json

"""# Objeto Pared
Se encarga de la lógica de las paredes, en nuestro caso
"""

class Wall:
    def __init__(self, wall_id=None, damage=0, door=0, enPie=True):
        self.id = wall_id
        self.damage = damage
        self.door = door
        self.enPie = enPie
        self.paredVecina = None

    # Detecta las parejas de paredes
    def setParedVecina(self, paredV):
        self.paredVecina = paredV

    # Función para abrir puertas (1=cerrada, 2=abierta)
    def abrir_door(self):
        if self.enPie and self.door == 1:
            self.door = 2
            if self.paredVecina:
                self.paredVecina.door = 2

    def cerrar_door(self):
        if self.enPie and self.door == 2:
            self.door = 1
            if self.paredVecina:
                self.paredVecina.door = 1

    # Hace daño a la pared y su vecina
    def afecta_wall(self):
        if self.enPie:
            self.damage += 1
            if self.damage >= 2:
                self.destruirWall()
            elif self.paredVecina:
                self.paredVecina.damage = self.damage

    # Destruye la pared y su vecina
    def destruirWall(self):
        if self.enPie:
            self.enPie = False
            self.door = 0
            self.damage = 2
            if self.paredVecina:
                self.paredVecina.enPie = False
                self.paredVecina.door = 0
                self.paredVecina.damage = 2

    def is_destroyed(self):
        return self.damage >= 2 or not self.enPie

    def puePasar(self):
        return self.is_destroyed() or self.door == 2

"""## Objeto celda
- Se encarga de la lógica de cada celda
- Crea paredes
"""

class Cell:
    def __init__(self, cell_id, wall_info="0000", door_info="0000", pos=None):
        self.id = cell_id
        self.pos = pos
        self.poi = 0
        self.poi_revelado = False
        self.smoke = False
        self.fire = False
        self.agents = []
        self.walls = self._crear_walls(wall_info, door_info)
        self.es_exterior = False
        self.wall_info_original = wall_info

    # Crea paredes: Norte(0), Oeste(1), Sur(2), Este(3)
    def _crear_walls(self, wall_info, door_info):
        walls = {}
        dir_mapping = {0: "N", 1: "O", 2: "S", 3: "E"}
        for i in range(min(4, len(wall_info))):
            if wall_info[i] == '1':
                dir_name = dir_mapping[i]
                door_state = int(door_info[i]) if i < len(door_info) and door_info[i] in ['1', '2'] else 0
                walls[dir_name] = Wall(wall_id=f"{self.id}-{dir_name}", door=door_state)
        return walls

"""# Agente astronauta"""

class AstronautAgent(Agent):
    def __init__(self, unique_id, model):
        super().__init__(model)
        self.unique_id = unique_id
        self.x = 0 # pos
        self.y = 0
        self.ap = 0
        self.max_ap = 4
        self.alive = True
        self.knockdowns = 0
        self.max_knockdowns = 2
        self.cargando_victima = False
        self.target = None
        self.tarea_asignada = None
        # New attributes for tracking actions
        self.fires_extinguished = 0
        self.smoke_extinguished = 0
        self.pois_revealed = 0
        self.victims_carried = 0

    def log(self, msg):
        print(f"    Agent-{self.unique_id}: {msg})")
        self.model._registrar_log(f"Agent-{self.unique_id}: {msg})")

    def reset_ap(self): # resetea el AP
        self.ap = self.max_ap + min(self.ap, 4)

    def recibir_dano(self):
        self.knockdowns += 1
        self.log(f"KNOCKDOWN! ({self.knockdowns}/{self.max_knockdowns})")

        if self.cargando_victima:
            self.cargando_victima = False
            celda = self.model.get_cell(self.x, self.y)
            if celda:
                celda.poi = 1
                celda.poi_revelado = True
            self.log("Victima soltada")

        if self.knockdowns >= self.max_knockdowns:
            self.alive = False
            self.log("AGENTE FUERA DE JUEGO")
            return False

        self.bestSalida()
        return True

    def bestSalida(self):
        """Tras knockdown, el agente va a la salida mas cercana"""
        if not self.model.salidas:
            return

        # Busca salida mas cercana
        mejor_salida = None
        mejor_dist = 9999
        for sal in self.model.salidas:
            # distancia manhattan de agente pos a cada salida
            dist = abs(self.x - sal[0]) + abs(self.y - sal[1])
            if dist < mejor_dist: # se almacena mejor distancia
                mejor_dist = dist
                mejor_salida = sal

        if mejor_salida is None:
            return

        # Quitar de celda actual
        celda_actual = self.model.get_cell(self.x, self.y)
        if celda_actual and self in celda_actual.agents:
            celda_actual.agents.remove(self)

        # Mover a salida
        self.x = mejor_salida[0]
        self.y = mejor_salida[1]
        celda_nueva = self.model.get_cell(self.x, self.y)
        if celda_nueva:
            celda_nueva.agents.append(self)
        self.log(f"Reubicado en salida ({self.x},{self.y})")

    def step(self):
        if not self.alive or self.model.juego_terminado:
            return
        self.log(f"Turno | Pos: ({self.x},{self.y}) | AP: {self.ap} | Tarea: {self.tarea_asignada})")

        acciones = 0
        while self.ap > 0 and acciones < 20 and not self.model.juego_terminado and self.alive:
            if self.model.estrategia == "random":
                if not self.estRandom():
                    break
            else:
                if not self.estInteligente():
                    break
            acciones += 1

    #Estrategia random
    def estRandom(self):
        celda = self.model.get_cell(self.x, self.y)

        if self.cargando_victima and self.model.es_salida(self.x, self.y):
            return self.soltarVictima()

        if celda.poi == 1 and celda.poi_revelado and not self.cargando_victima:
            return self._cargar_victima()

        if celda.poi > 0 and not celda.poi_revelado:
            return self._revelar_poi(celda)

        dirs = ['N', 'S', 'E', 'O']
        random.shuffle(dirs)

        for d in dirs:
            vecino_pos = self.model.get_neighbor_dir(self.x, self.y, d)
            if not vecino_pos:
                continue
            celda_destino = self.model.get_cell(*vecino_pos)
            if not celda_destino:
                continue

            if celda_destino.fire and self.ap >= 2 and self._puede_ver(d):
                celda_destino.fire = False
                celda_destino.smoke = True
                self.ap -= 2
                self.fires_extinguished += 1 # Increment tracking attribute
                self.log(f"Apago fuego en {vecino_pos} [-2 AP]")
                self.model._registrar_accion(self.unique_id, "extinguir_fuego", (self.x, self.y), vecino_pos, 2)
                return True

            if self._mover(d):
                return True
        return False

    def _puede_ver(self, direccion):
        celda = self.model.get_cell(self.x, self.y)
        if direccion in celda.walls:
            pared = celda.walls[direccion]
            if pared.enPie and not pared.is_destroyed() and pared.door == 0:
                return False
        return True

    # =========================================================================

    def estInteligente(self):
        celda = self.model.get_cell(self.x, self.y)

        # P1: Depositar víctima en salida
        if self.cargando_victima and self.model.es_salida(self.x, self.y):
            return self.soltarVictima()

        # P2: Llevar víctima a salida
        if self.cargando_victima:
            return self.salir()

        # P3: Cargar víctima revelada
        if celda.poi == 1 and celda.poi_revelado:
            return self._cargar_victima()

        # P4: Revelar POI
        if celda.poi > 0 and not celda.poi_revelado:
            return self._revelar_poi(celda)

        # P5: Apagar fuego/humo en celda actual
        if celda.fire or celda.smoke:
            return self._extinguir(celda)

        # P6: Apagar fuego/humo ADYACENTE (sin moverse - más eficiente)
        for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]:
            nx, ny = self.x + dx, self.y + dy
            vecino = self.model.cells.get((nx, ny))
            if vecino and not self.model.paredEntremedio(self.x, self.y, nx, ny):
                if vecino.fire and self.ap >= 2:
                    vecino.fire, vecino.smoke = False, True
                    self.ap -= 2
                    self.fires_extinguished += 1 # Increment tracking attribute
                    self.log(f"Apago arana adyacente ({nx},{ny}) [-2 AP]")
                    self.model._registrar_accion(self.unique_id, "extinguir_fuego", (self.x, self.y), (nx, ny), 2)
                    return True
                elif vecino.smoke and self.ap >= 1:
                    vecino.smoke = False
                    self.ap -= 1
                    self.smoke_extinguished += 1 # Increment tracking attribute
                    self.log(f"Apago huevo adyacente ({nx},{ny}) [-1 AP]")
                    self.model._registrar_accion(self.unique_id, "extinguir_humo", (self.x, self.y), (nx, ny), 1)
                    return True

        # P7: Seguir tarea asignada
        if self.target and self.tarea_asignada:
            return self._seguir_tarea()

        # P8: Buscar algo útil
        return self._buscar_tarea_autonoma()

    def soltarVictima(self):
        self.cargando_victima = False
        self.model.victims_rescued += 1
        self.tarea_asignada = None
        self.target = None
        self.log(f"*** VICTIMA RESCATADA! Total: {self.model.victims_rescued}/7 ***")
        self.model._registrar_accion(self.unique_id, "depositar_victima", (self.x, self.y), (self.x, self.y), 0)
        if self.model.victims_rescued >= 7:
            self.model.juego_terminado = True
            self.model.resultado = "VICTORIA"
        return True

    def _cargar_victima(self):
        celda = self.model.get_cell(self.x, self.y)
        if celda.poi == 1 and celda.poi_revelado and not self.cargando_victima:
            self.cargando_victima = True
            self.victims_carried += 1 # Increment tracking attribute
            celda.poi = 0
            celda.poi_revelado = False
            self.tarea_asignada = 'llevar_victima'
            self.target = self.salidaBarata()
            self.log(f"Cargo victima")
            self.model._registrar_accion(self.unique_id, "recoger_victima", (self.x, self.y), (self.x, self.y), 0)
            return True
        return False

    def _revelar_poi(self, celda):
        celda.poi_revelado = True
        self.pois_revealed += 1 # Increment tracking attribute
        tipo = "VICTIMA" if celda.poi == 1 else "Falsa alarma"
        self.log(f"Revelo POI: {tipo}!")
        self.model._registrar_accion(self.unique_id, "revelar_poi", (self.x, self.y), (self.x, self.y), 0,
            {"resultado": "victima" if celda.poi == 1 else "falsa_alarma"})
        if celda.poi == 1:
            return self._cargar_victima()
        else:
            celda.poi = 0
            celda.poi_revelado = False
            self.tarea_asignada = None
            self.target = None
            return True

    def _extinguir(self, celda):
        hizo_algo = False
        # Apagar fuego primero
        while celda.fire and self.ap >= 2:
            celda.fire = False
            celda.smoke = True
            self.ap -= 2
            self.fires_extinguished += 1 # Increment tracking attribute
            self.log(f"Apago fuego -> humo [-2 AP]")
            self.model._registrar_accion(self.unique_id, "extinguir_fuego", (self.x, self.y), (self.x, self.y), 2)
            hizo_algo = True
        # Luego humo si sobra AP
        while celda.smoke and self.ap >= 1:
            celda.smoke = False
            self.ap -= 1
            self.smoke_extinguished += 1 # Increment tracking attribute
            self.log(f"Apago humo [-1 AP]")
            self.model._registrar_accion(self.unique_id, "extinguir_humo", (self.x, self.y), (self.x, self.y), 1)
            hizo_algo = True
        return hizo_algo

    def _seguir_tarea(self):
        if not self.target:
            self.tarea_asignada = None
            return False

        # Si llego al objetivo
        if (self.x, self.y) == self.target:
            celda = self.model.get_cell(self.x, self.y)

            if self.tarea_asignada in ['investigar_poi', 'rescatar_victima']:
                if celda.poi > 0 and not celda.poi_revelado:
                    return self._revelar_poi(celda)
                if celda.poi == 1 and celda.poi_revelado:
                    return self._cargar_victima()
                self.tarea_asignada = None
                self.target = None
                return False

            elif self.tarea_asignada == 'llevar_victima':
                if self.cargando_victima:
                    return self.soltarVictima()
                self.tarea_asignada = None
                self.target = None
                return False

            elif self.tarea_asignada in ['apagar_fuego', 'apagar_humo', 'prevenir_dano']:
                if celda.fire or celda.smoke:
                    return self._extinguir(celda)
                self.tarea_asignada = None
                self.target = None
                return False

        # Calcular camino al objetivo
        camino = self.a_estrella(self.target)
        if not camino or len(camino) == 0:
            self.tarea_asignada = None
            self.target = None
            return False

        # Ver siguiente celda en el camino
        sig_pos = self.model.get_neighbor_dir(self.x, self.y, camino[0])
        if not sig_pos:
            return False

        celda_sig = self.model.get_cell(sig_pos[0], sig_pos[1])
        if not celda_sig:
            return False

        # Si hay fuego, apagarlo DESDE AFUERA (no entrar)
        if celda_sig.fire:
            if self.ap >= 2:
                celda_sig.fire = False
                celda_sig.smoke = True
                self.ap -= 2
                self.fires_extinguished += 1 # Increment tracking attribute
                self.log(f"Apago fuego en camino ({sig_pos[0]},{sig_pos[1]}) [-2 AP]")
                self.model._registrar_accion(self.unique_id, "extinguir_fuego", (self.x, self.y), sig_pos, 2)
                # NO moverse, solo apagar. En la siguiente iteracion entrara al humo.
                return True
            else:
                return False

        # Si hay humo y es mi destino, apagarlo primero
        if celda_sig.smoke and sig_pos == self.target:
            if self.ap >= 1:
                celda_sig.smoke = False
                self.ap -= 1
                self.smoke_extinguished += 1 # Increment tracking attribute
                self.log(f"Apago huevo en destino ({sig_pos[0]},{sig_pos[1]}) [-1 AP]")
                self.model._registrar_accion(self.unique_id, "extinguir_humo", (self.x, self.y), sig_pos, 1)
                return True

        # Moverse
        return self._mover_hacia(self.target)

    def _buscar_tarea_autonoma(self):
        """Busca una tarea cuando no tiene asignada. Usa costo AP."""

        # Buscar POI mas barato (para rescatar victimas)
        mejor_poi = None
        mejor_costo = 9999
        for pos, celda in self.model.cells.items():
            if celda.poi > 0 and not celda.es_exterior and not celda.fire:
                costo = self.calcular_costo_ap(pos)
                if costo < mejor_costo:
                    mejor_costo = costo
                    mejor_poi = pos

        if mejor_poi:
            self.target = mejor_poi
            self.tarea_asignada = 'investigar_poi'
            return self._seguir_tarea()

        # Si no hay POI, buscar fuego mas barato
        mejor_fuego = None
        mejor_costo = 9999
        for pos, celda in self.model.cells.items():
            if celda.fire and not celda.es_exterior:
                costo = self.calcular_costo_ap(pos)
                if costo < mejor_costo:
                    mejor_costo = costo
                    mejor_fuego = pos

        if mejor_fuego:
            self.target = mejor_fuego
            self.tarea_asignada = 'apagar_fuego'
            return self._seguir_tarea()

        return self._explorar()

    def _mover_hacia(self, objetivo):
        camino = self.a_estrella(objetivo)
        if not camino:
            self.tarea_asignada = None
            self.target = None
            return False
        return self._mover(camino[0]) if camino else False

    def _mover(self, direccion):
        if self.ap <= 0 or not self.alive:
            return False

        celda_actual = self.model.get_cell(self.x, self.y)
        opuestas = {"N": "S", "S": "N", "E": "O", "O": "E"}

        # Verificar pared/puerta
        if direccion in celda_actual.walls:
            pared = celda_actual.walls[direccion]
            if pared.enPie and not pared.is_destroyed():
                if pared.door == 1:
                    if self.ap >= 1:
                        pared.abrir_door()
                        self.ap -= 1
                        self.log(f"Abrio puerta [-1 AP]")
                        vecino = self.model.get_neighbor_dir(self.x, self.y, direccion)
                        self.model._registrar_accion(self.unique_id, "abrir_puerta", (self.x, self.y), vecino, 1)
                    else:
                        return False
                elif pared.door == 0:
                    return False

        vecino = self.model.get_neighbor_dir(self.x, self.y, direccion)
        if not vecino:
            return False

        nx, ny = vecino
        celda_destino = self.model.get_cell(nx, ny)
        if not celda_destino:
            return False

        # Verificar desde el otro lado
        if opuestas[direccion] in celda_destino.walls:
            pared = celda_destino.walls[opuestas[direccion]]
            if pared.enPie and not pared.is_destroyed() and pared.door == 0:
                return False

        costo = 2 if self.cargando_victima else 1
        if celda_destino.fire:
            costo += 1

        if self.ap < costo:
            return False

        # Ejecutar
        pos_ant = (self.x, self.y)
        if self in celda_actual.agents:
            celda_actual.agents.remove(self)
        self.x, self.y = nx, ny
        self.ap -= costo
        celda_destino.agents.append(self)

        self.log(f"Movio {pos_ant} -> ({nx},{ny}) [-{costo} AP]")
        self.model._registrar_accion(self.unique_id, "mover", pos_ant, (nx, ny), costo)

        if celda_destino.fire:
            self.recibir_dano()
        if celda_destino.poi > 0 and not celda_destino.poi_revelado:
            self._revelar_poi(celda_destino)
        return True

    def salir(self):
        salida = self.salidaBarata()
        if salida:
            self.target = salida
            return self._mover_hacia(salida)
        return False

    def salidaBarata(self):
        if not self.model.salidas:
            return None

        mejor_salida = None
        mejor_costo = 9999
        for sal in self.model.salidas:
            costo = self.calcular_costo_ap(sal)
            if costo < mejor_costo:
                mejor_costo = costo
                mejor_salida = sal
        return mejor_salida

    def _explorar(self):
        dirs = ['N', 'S', 'E', 'O']
        random.shuffle(dirs)
        for d in dirs:
            if self._mover(d):
                return True
        return False

    def a_estrella(self, objetivo):
        inicio = (self.x, self.y)
        if inicio == objetivo:
            return []

        frontera = [(0, 0, inicio)]
        heapq.heapify(frontera)
        vino_de = {inicio: None}
        costo_g = {inicio: 0}
        dirs = {'N': (0, -1), 'S': (0, 1), 'E': (1, 0), 'O': (-1, 0)}

        while frontera:
            _, g, pos = heapq.heappop(frontera)
            if pos == objetivo:
                return self._reconstruir(vino_de, inicio, objetivo)

            celda = self.model.get_cell(*pos)
            if not celda:
                continue

            for d, (dx, dy) in dirs.items():
                vec = (pos[0] + dx, pos[1] + dy)
                if not (0 <= vec[0] < self.model.width and 0 <= vec[1] < self.model.height):
                    continue
                celda_v = self.model.get_cell(*vec)
                if not celda_v or celda_v.es_exterior:
                    continue

                costo = self._costo_paso(celda, celda_v, d)
                if costo is None:
                    continue

                nuevo_g = g + costo
                if vec not in costo_g or nuevo_g < costo_g[vec]:
                    costo_g[vec] = nuevo_g
                    f = nuevo_g + abs(vec[0] - objetivo[0]) + abs(vec[1] - objetivo[1])
                    heapq.heappush(frontera, (f, nuevo_g, vec))
                    vino_de[vec] = (pos, d)
        return None

    def _costo_paso(self, c1, c2, d):
        op = {"N": "S", "S": "N", "E": "O", "O": "E"}
        costo = 0
        if d in c1.walls:
            p = c1.walls[d]
            if p.enPie and not p.is_destroyed():
                if p.door == 2: pass
                elif p.door == 1: costo += 1
                else: return None
        if op[d] in c2.walls:
            p = c2.walls[op[d]]
            if p.enPie and not p.is_destroyed():
                if p.door == 2: pass
                elif p.door == 1: costo += 1
                else: return None
        return costo + (2 if self.cargando_victima else 1) + (10 if c2.fire else 0)

    def _reconstruir(self, vino_de, inicio, objetivo):
        camino = []
        actual = objetivo
        while actual != inicio:
            if actual not in vino_de or vino_de[actual] is None:
                return []
            ant, d = vino_de[actual]
            camino.append(d)
            actual = ant
        camino.reverse()
        return camino

    def calcular_costo_ap(self, objetivo):
        """
        Calcula el costo en AP para llegar al objetivo usando A*.
        Retorna el costo total o 9999 si no hay camino.
        """
        inicio = (self.x, self.y)
        if inicio == objetivo:
            return 0

        frontera = [(0, 0, inicio)]
        heapq.heapify(frontera)
        costo_g = {inicio: 0}
        dirs = {'N': (0, -1), 'S': (0, 1), 'E': (1, 0), 'O': (-1, 0)}

        while frontera:
            _, g, pos = heapq.heappop(frontera)

            if pos == objetivo:
                return costo_g[objetivo]

            celda = self.model.get_cell(pos[0], pos[1])
            if not celda:
                continue

            for d in dirs:
                dx = dirs[d][0]
                dy = dirs[d][1]
                vec = (pos[0] + dx, pos[1] + dy)

                if vec[0] < 0 or vec[0] >= self.model.width:
                    continue
                if vec[1] < 0 or vec[1] >= self.model.height:
                    continue

                celda_v = self.model.get_cell(vec[0], vec[1])
                if not celda_v or celda_v.es_exterior:
                    continue

                costo = self._costo_paso(celda, celda_v, d)
                if costo is None:
                    continue

                nuevo_g = costo_g[pos] + costo
                if vec not in costo_g or nuevo_g < costo_g[vec]:
                    costo_g[vec] = nuevo_g
                    h = abs(vec[0] - objetivo[0]) + abs(vec[1] - objetivo[1])
                    f = nuevo_g + h
                    heapq.heappush(frontera, (f, nuevo_g, vec))

        return 9999  # No hay camino

"""# Sistema de subastas

Sistema de subastas donde cada agente ofrece el costo en AP para llegar a cada tarea. El agente con menor costo AP gana la tarea.


"""

class AgenteSubasta:


    def __init__(self, model):
        self.model = model

    def log(self, msg):
        print(f"  SUBASTA {msg}")
        self.model._registrar_log(f"SUBASTA {msg}")

    def subastar_tareas(self):
        self.log(" SUBASTA DE TAREAS")

        # Limpiar asignaciones previas (excepto los que cargan victima)
        for a in self.model.astronautas:
            if a.alive and not a.cargando_victima:
                a.tarea_asignada = None
                a.target = None

        # Obtener agentes disponibles
        disponibles = []
        for a in self.model.astronautas:
            if a.alive and not a.cargando_victima:
                disponibles.append(a)

        # 1 Asignar agentes que cargan victima (FORZADO)
        for a in self.model.astronautas:
            if a.cargando_victima and a.alive:
                # Buscar salida mas cercana
                mejor_salida = None
                mejor_costo = 9999
                for sal in self.model.salidas:
                    costo = a.calcular_costo_ap(sal)
                    if costo < mejor_costo:
                        mejor_costo = costo
                        mejor_salida = sal

                a.tarea_asignada = 'llevar_victima'
                a.target = mejor_salida
                self.log(f"Agente {a.unique_id} -> llevar_victima [FORZADO] (costo: {mejor_costo} AP)")

        # PASO 2: Victimas reveladas esperando rescate (MAXIMA PRIORIDAD)
        victimas_reveladas = []
        for pos, celda in self.model.cells.items():
            if celda.poi == 1 and celda.poi_revelado and not celda.es_exterior:
                victimas_reveladas.append(pos)

        for vic_pos in victimas_reveladas:
            if not disponibles:
                break

            # Cada agente hace su oferta (costo AP)
            mejor_agente = None
            mejor_oferta = 9999

            for a in disponibles:
                oferta = a.calcular_costo_ap(vic_pos)
                if oferta < mejor_oferta:
                    mejor_oferta = oferta
                    mejor_agente = a

            if mejor_agente:
                mejor_agente.tarea_asignada = 'rescatar_victima'
                mejor_agente.target = vic_pos
                disponibles.remove(mejor_agente)
                self.log(f"Agente {mejor_agente.unique_id} -> rescatar_victima en {vic_pos} (oferta: {mejor_oferta} AP)")

        # PASO 3: POIs no revelados (buscar victimas)
        pois = []
        for pos, celda in self.model.cells.items():
            if celda.poi > 0 and not celda.poi_revelado and not celda.es_exterior and not celda.fire:
                pois.append(pos)

        # Cuantos agentes asignar a POIs segun victimas faltantes
        victimas_faltantes = 7 - self.model.victims_rescued
        if victimas_faltantes >= 6:
            max_agentes_poi = 4
        elif victimas_faltantes >= 4:
            max_agentes_poi = 3
        elif victimas_faltantes >= 2:
            max_agentes_poi = 2
        else:
            max_agentes_poi = 1

        agentes_asignados_poi = 0

        while agentes_asignados_poi < max_agentes_poi and pois and disponibles:
            # Buscar mejor par agente-POI por costo AP
            mejor_agente = None
            mejor_poi = None
            mejor_oferta = 9999

            for a in disponibles:
                for poi in pois:
                    oferta = a.calcular_costo_ap(poi)
                    if oferta < mejor_oferta:
                        mejor_oferta = oferta
                        mejor_agente = a
                        mejor_poi = poi

            if mejor_agente and mejor_poi:
                mejor_agente.tarea_asignada = 'investigar_poi'
                mejor_agente.target = mejor_poi
                disponibles.remove(mejor_agente)
                pois.remove(mejor_poi)
                agentes_asignados_poi += 1
                self.log(f"Agente {mejor_agente.unique_id} -> investigar_poi en {mejor_poi} (oferta: {mejor_oferta} AP)")
            else:
                break

        # PASO 4: Fuegos (resto de agentes)

        # Obtener fuegos, priorizando bordes (menos vecinos con fuego)
        fuegos = []
        for pos, celda in self.model.cells.items():
            if celda.fire and not celda.es_exterior:
                # Contar vecinos con fuego
                vecinos_fuego = 0
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    vecino_pos = (pos[0] + dx, pos[1] + dy)
                    vecino = self.model.cells.get(vecino_pos)
                    if vecino and vecino.fire:
                        vecinos_fuego += 1
                fuegos.append((pos, vecinos_fuego))

        # Ordenar: menos vecinos primero (bordes del incendio)
        fuegos.sort(key=lambda x: x[1])
        fuegos_pos = [f[0] for f in fuegos]

        fuegos_asignados = set()

        for a in disponibles[:]:  # Copia para poder modificar
            if not fuegos_pos:
                break

            # Agente busca fuego mas barato que no este asignado
            mejor_fuego = None
            mejor_oferta = 9999

            for fuego in fuegos_pos:
                if fuego in fuegos_asignados:
                    continue
                oferta = a.calcular_costo_ap(fuego)
                if oferta < mejor_oferta:
                    mejor_oferta = oferta
                    mejor_fuego = fuego

            if mejor_fuego:
                a.tarea_asignada = 'apagar_fuego'
                a.target = mejor_fuego
                fuegos_asignados.add(mejor_fuego)
                disponibles.remove(a)
                self.log(f"Agente {a.unique_id} -> apagar_fuego en {mejor_fuego} (oferta: {mejor_oferta} AP)")

"""# Modelo Nave"""

class Nave(Model):
    def __init__(self, width=8, height=6, num_agents=6, mapa_texto=None, estrategia="inteligente"):
        super().__init__()
        self.width = width
        self.height = height
        self.damage_counter = 0
        self.victims_rescued = 0
        self.victims_lost = 0
        self.turn = 0
        self.juego_terminado = False
        self.resultado = None
        self.total_explosions = 0
        self.total_flashovers = 0
        self.estrategia = estrategia

        self.grid = MultiGrid(width, height, torus=False)
        self.cells = {}
        self.astronautas = []
        self.salidas = []
        self.entradas = []

        self.historial_turnos = []
        self._acciones_turno_actual = []
        self._logs_turno_actual = []
        self._dados_turno_actual = []

        self._todos_los_logs = []
        self._estado_inicial_guardado = None

        if mapa_texto:
            self.cargar_desde_texto(mapa_texto)

        self._vincular_paredes()
        self.auctioneer = AgenteSubasta(self)
        self._crear_agentes(num_agents)
        
        # Guardar estado inicial ANTES de cualquier turno
        self._estado_inicial_guardado = self._construir_estado_inicial()

        # Initialize DataCollector
        self.datacollector = DataCollector(
            model_reporters={
                "Turno": "turn",
                "VictimasRescatadas": "victims_rescued",
                "VictimasPerdidas": "victims_lost",
                "DanoEstructural": "damage_counter",
                "ExplosionesTotales": "total_explosions",
                "FlashoversTotales": "total_flashovers"
            },
            agent_reporters={
                "FiresExtinguished": "fires_extinguished",
                "SmokeExtinguished": "smoke_extinguished",
                "POIsRevealed": "pois_revealed",
                "VictimsCarried": "victims_carried",
                "IsAlive": "alive",
                "Knockdowns": "knockdowns",
                "CargandoVictima": "cargando_victima",
                "PosicionX": "x",
                "PosicionY": "y"
            }
        )

    def log(self, msg):
        print(f"  {msg}")
        self._registrar_log(msg)


    def _registrar_log(self, msg):
        self._logs_turno_actual.append(msg)
        self._todos_los_logs.append({
            "turno": self.turn,
            "mensaje": msg
        })

    def _registrar_accion(self, aid, tipo, desde, hacia, costo, extras=None):
        self._acciones_turno_actual.append({
            "agente_id": aid,  # Para agrupar acciones por agente
            "tripulacion_id": aid + 1, "tipo": tipo,
            "desde": {"fila": desde[1] + 1, "columna": desde[0] + 1},
            "hacia": {"fila": hacia[1] + 1, "columna": hacia[0] + 1},
            "costo_ap": costo, "cambios": extras or {}
        })

    def cargar_desde_texto(self, texto):
        lineas = [l.strip() for l in texto.strip().split('\n') if l.strip()]
        idx = 0
        self.log("Cargando mapa...")

        for y in range(self.height):
            if idx >= len(lineas): break
            for x, g in enumerate(lineas[idx].split()):
                if len(g) >= 4:
                    self.cells[(x, y)] = Cell(cell_id=f"{x}-{y}", wall_info=g[:4], pos=(x, y))
            idx += 1

        # POIs
        while idx < len(lineas):
            p = lineas[idx].split()
            if len(p) >= 3 and p[2].lower() in ['v', 'f']:
                f, c = int(p[0]) - 1, int(p[1]) - 1
                if (c, f) in self.cells:
                    self.cells[(c, f)].poi = 1 if p[2].lower() == 'v' else 2
                idx += 1
            else: break

        # Fuegos
        while idx < len(lineas):
            p = lineas[idx].split()
            if len(p) == 2:
                try:
                    f, c = int(p[0]) - 1, int(p[1]) - 1
                    if (c, f) in self.cells:
                        self.cells[(c, f)].fire = True
                    idx += 1
                except: break
            else: break

        # Puertas
        while idx < len(lineas):
            p = lineas[idx].split()
            if len(p) >= 4:
                try:
                    r1, c1, r2, c2 = [int(x) - 1 for x in p[:4]]
                    self._colocar_puerta(c1, r1, c2, r2)
                    idx += 1
                except: break
            else: break

        # Entradas
        while idx < len(lineas):
            p = lineas[idx].split()
            if len(p) >= 2:
                try:
                    f, c = int(p[0]) - 1, int(p[1]) - 1
                    self.entradas.append((c, f))
                    self.salidas.append((c, f))
                    idx += 1
                except: break
            else: break

        self.log(f"Mapa: {len(self.cells)} celdas, {len(self.entradas)} entradas")

    def _colocar_puerta(self, x1, y1, x2, y2):
        if (x1, y1) not in self.cells or (x2, y2) not in self.cells: return
        dx, dy = x2 - x1, y2 - y1
        dm = {(0, -1): 'N', (0, 1): 'S', (1, 0): 'E', (-1, 0): 'O'}
        op = {'N': 'S', 'S': 'N', 'E': 'O', 'O': 'E'}
        d = dm.get((dx, dy))
        if d:
            if d in self.cells[(x1, y1)].walls: self.cells[(x1, y1)].walls[d].door = 1
            if op[d] in self.cells[(x2, y2)].walls: self.cells[(x2, y2)].walls[op[d]].door = 1

    def _vincular_paredes(self):
        op = {"N": "S", "S": "N", "E": "O", "O": "E"}
        dl = {"N": (0, -1), "S": (0, 1), "E": (1, 0), "O": (-1, 0)}
        for (x, y), c in self.cells.items():
            for d, w in c.walls.items():
                nx, ny = x + dl[d][0], y + dl[d][1]
                if (nx, ny) in self.cells and op[d] in self.cells[(nx, ny)].walls:
                    w.setParedVecina(self.cells[(nx, ny)].walls[op[d]])

    def _crear_agentes(self, n):
        """Crea agentes distribuidos en las diferentes entradas"""
        for i in range(n):
            # Distribuir en entradas disponibles (round-robin)
            ent = self.entradas[i % len(self.entradas)] if self.entradas else (0, 0)
            a = AstronautAgent(i, self)
            a.x, a.y = ent
            if ent in self.cells:
                self.cells[ent].agents.append(a)
            self.grid.place_agent(a, ent)
            self.astronautas.append(a)
        self.log(f"Creados {n} agentes distribuidos en {len(self.entradas)} entradas [estrategia: {self.estrategia}]")

    def get_cell(self, x, y): return self.cells.get((x, y))

    def get_neighbor_dir(self, x, y, d):
        dl = {'N': (0, -1), 'S': (0, 1), 'E': (1, 0), 'O': (-1, 0)}
        if d not in dl: return None
        nx, ny = x + dl[d][0], y + dl[d][1]
        return (nx, ny) if (nx, ny) in self.cells else None

    def es_salida(self, x, y): return (x, y) in self.salidas

    def paredEntremedio(self, x1, y1, x2, y2):
        c = self.get_cell(x1, y1)
        if not c: return False
        dm = {(0, -1): 'N', (0, 1): 'S', (1, 0): 'E', (-1, 0): 'O'}
        d = dm.get((x2 - x1, y2 - y1))
        return d in c.walls and not c.walls[d].puePasar() if d else False

    def avanzar_fuego(self):
        dr, dn = random.randint(1, 6), random.randint(1, 8)
        x, y = dn - 1, dr - 1
        self.log(f"Dados: {dr},{dn} -> ({x},{y})")

        tirada = {"dado_rojo": dr, "dado_negro": dn, "fila": y + 1, "columna": x + 1}

        if (x, y) not in self.cells:
            tirada.update({"estado_anterior": "fuera", "estado_nuevo": "fuera", "cambios": {}})
            self._dados_turno_actual.append(tirada)
            return

        c = self.cells[(x, y)]
        if c.fire:
            # IMPORTANTE: La araña (fuego) permanece después de la explosión
            # Solo registramos que hubo una explosión en los cambios
            explosion_cambios = self._explosion(x, y)
            explosion_cambios["es_explosion"] = True  # Marcador para Unity
            tirada.update({"estado_anterior": "araña", "estado_nuevo": "araña", "cambios": explosion_cambios})
        elif c.smoke:
            c.smoke, c.fire = False, True
            tirada.update({"estado_anterior": "huevo", "estado_nuevo": "araña", "cambios": {}})
        else:
            c.smoke = True
            tirada.update({"estado_anterior": "vacio", "estado_nuevo": "huevo", "cambios": {}})

        self._dados_turno_actual.append(tirada)
        self._flashover()
        self._verificar_victimas()

    def _explosion(self, x, y):
        self.total_explosions += 1
        self.log(f" EXPLOSION ({x},{y})")
        cambios = {"paredes_danadas": [], "fuego_propagado": [], "knockdowns": []}
        c = self.cells[(x, y)]
        dirs = {'N': (0, -1), 'S': (0, 1), 'E': (1, 0), 'O': (-1, 0)}

        # Knockdown agentes en celda de explosión
        for a in c.agents[:]:
            if a.alive:
                self.log(f"  Agente {a.unique_id} alcanzado por explosion!")
                cambios["knockdowns"].append(a.unique_id)
                a.recibir_dano()

        for d, (dx, dy) in dirs.items():
            nx, ny = x + dx, y + dy
            if d in c.walls:
                p = c.walls[d]
                if p.enPie and not p.is_destroyed():
                    if p.door == 1:
                        p.destruirWall()
                        cambios["paredes_danadas"].append({"dir": d, "estado": "destruida"})
                    else:
                        p.afecta_wall()
                        self.damage_counter += 1
                        cambios["paredes_danadas"].append({"dir": d, "dano": p.damage})
                    continue
            if (nx, ny) in self.cells:
                v = self.cells[(nx, ny)]
                # Knockdown agentes en celdas adyacentes afectadas por fuego
                if not v.fire:
                    for a in v.agents[:]:
                        if a.alive:
                            self.log(f"  Agente {a.unique_id} alcanzado por fuego de explosion!")
                            cambios["knockdowns"].append(a.unique_id)
                            a.recibir_dano()
                if v.fire:
                    self._shockwave(nx, ny, dx, dy, cambios)
                else:
                    v.smoke, v.fire = False, True
                    cambios["fuego_propagado"].append((nx, ny))

        # Ya no sumamos daño extra - solo cuenta el daño a paredes
        self.log(f"Dano: {self.damage_counter}/24")
        if self.damage_counter >= 24:
            self.juego_terminado = True
            self.resultado = "DERROTA - Colapso"
        return cambios

    def _shockwave(self, x, y, dx, dy, cambios):
        for _ in range(8):
            x, y = x + dx, y + dy
            if (x, y) not in self.cells: break
            if self.paredEntremedio(x - dx, y - dy, x, y):
                self.damage_counter += 1
                break
            c = self.cells[(x, y)]
            if not c.fire:
                c.smoke, c.fire = False, True
                cambios["fuego_propagado"].append((x, y))
                break

    def _flashover(self):
        changed = True
        while changed:
            changed = False
            for (x, y), c in self.cells.items():
                if c.smoke:
                    for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                        nx, ny = x + dx, y + dy
                        if (nx, ny) in self.cells:
                            v = self.cells[(nx, ny)]
                            if v.fire and not self.paredEntremedio(x, y, nx, ny):
                                c.smoke, c.fire = False, True
                                self.total_flashovers += 1
                                changed = True
                                break

    def _verificar_victimas(self):
        for (x, y), c in self.cells.items():
            if c.fire and c.poi == 1:
                self.victims_lost += 1
                c.poi, c.poi_revelado = 0, False
                self.log(f"VICTIMA PERDIDA ({x},{y})! {self.victims_lost}/4 ***")
                if self.victims_lost >= 4:
                    self.juego_terminado = True
                    self.resultado = "DERROTA - 4 victimas"

    def reponer_poi(self):
        if self.juego_terminado: return
        total = sum(1 for c in self.cells.values() if c.poi > 0 and not c.poi_revelado)
        vict = sum(1 for c in self.cells.values() if c.poi == 1 and c.poi_revelado)
        while total + vict < 3:
            x, y = random.randint(0, self.width - 1), random.randint(0, self.height - 1)
            c = self.cells.get((x, y))
            if c and not c.fire and not c.smoke and c.poi == 0:
                c.poi = 1 if random.random() < 0.67 else 2
                self.log(f"Nuevo POI en ({x},{y})")
                total += 1

    def _capturar_estado(self):
        dn = {'N': 'norte', 'S': 'sur', 'E': 'este', 'O': 'oeste'}
        return {
            "tripulacion": [{"id": a.unique_id + 1, "fila": a.y + 1, "columna": a.x + 1,
                            "ap": a.ap, "victima": a.cargando_victima, "vivo": a.alive,
                            "tarea": a.tarea_asignada} for a in self.astronautas],
            "pois": [{"fila": y + 1, "columna": x + 1, "revelado": c.poi_revelado,
                     "tipo": "v" if c.poi == 1 else "f"} for (x, y), c in self.cells.items() if c.poi > 0],
            "fuegos": [{"fila": y + 1, "columna": x + 1} for (x, y), c in self.cells.items() if c.fire],
            "humos": [{"fila": y + 1, "columna": x + 1} for (x, y), c in self.cells.items() if c.smoke],
            "dano": self.damage_counter, "rescatadas": self.victims_rescued, "perdidas": self.victims_lost
        }

    def ejecutar_turno(self):
        if self.juego_terminado: return False

        self.turn += 1
        self._acciones_turno_actual = []
        self._logs_turno_actual = []
        self._dados_turno_actual = []

        print(f"\n{'='*50}\n RONDA {self.turn} [{self.estrategia.upper()}]\n{'='*50}")
        print(f"Rescatadas: {self.victims_rescued}/7 | Perdidas: {self.victims_lost}/4 | Dano: {self.damage_counter}/24")

        # Reset AP
        print("\n-- Reset AP --")
        for a in self.astronautas:
            if a.alive:
                a.reset_ap()
                print(f"  Agent-{a.unique_id}: {a.ap} AP")

        # Asignar tareas
        print("\n-- Asignacion --")
        if self.estrategia == "inteligente":
            self.auctioneer.subastar_tareas()
        else:
            print("  [Random]")

        # Turnos
        print("\n-- Turnos --")
        for a in self.astronautas:
            if a.alive and not self.juego_terminado:
                print(f"\n  === AGENTE {a.unique_id} ===")
                a.step()
                if not self.juego_terminado:
                    print("  -- Dados --")
                    self.avanzar_fuego()

        if not self.juego_terminado:
            print("\n-- Reponer POIs --")
            self.reponer_poi()

        if self.victims_rescued >= 7:
            self.juego_terminado = True
            self.resultado = "VICTORIA"

        self.historial_turnos.append({
            "turno": self.turn, "dados": self._dados_turno_actual,
            "acciones": self._acciones_turno_actual, "estado": self._capturar_estado(),
            "logs": self._logs_turno_actual
        })

        # Collect data after each turn
        self.datacollector.collect(self)

        if self.juego_terminado:
            print(f"\n{'='*60}\n{self.resultado}\nTurnos: {self.turn}, Rescatadas: {self.victims_rescued}/7")
        return not self.juego_terminado

    def get_estado_inicial(self):
        return {
            "tablero": {"filas": self.height, "columnas": self.width,
                       "celdas": [self.cells.get((x, y)).wall_info_original if (x, y) in self.cells else "0000"
                                 for y in range(self.height) for x in range(self.width)]},
            "entradas": [{"fila": y + 1, "columna": x + 1} for x, y in self.entradas],
            "estrategia": self.estrategia, "agentes": len(self.astronautas)
        }

    def exportar_json(self):
        return json.dumps({"inicial": self.get_estado_inicial(), "turnos": self.historial_turnos}, indent=2, ensure_ascii=False)

    def get_ultimo_turno(self):
        return self.historial_turnos[-1] if self.historial_turnos else None

    def exportar_stats_csv(self):

        model_df = self.datacollector.get_model_vars_dataframe()
        agent_df = self.datacollector.get_agent_vars_dataframe()

        model_df.to_csv("model_data.csv", index=False)
        agent_df.to_csv("agent_data.csv", index=True)

        self.log("\n Model statistics saved to model_data.csv")
        self.log(" Agent statistics saved to agent_data.csv")

    # =========================================================================

    def generar_json_formato_ejemplo(self):
        """
        Genera JSON con estructura IDÉNTICA al ejemplo.
        Terminología: araña=fuego, huevo=humo
        """
        return json.dumps({
            "tablero": self._construir_tablero(),
            "estado_inicial": self._estado_inicial_guardado if self._estado_inicial_guardado else self._construir_estado_inicial(),
            "turnos": [self._construir_turno(t) for t in self.historial_turnos]
        }, indent=2, ensure_ascii=False)


    def _construir_tablero(self):
        """Construye sección tablero"""
        return {
            "fila": self.height,
            "columna": self.width,
            "celdas": [
                self.cells.get((x, y)).wall_info_original if (x, y) in self.cells else "0000"
                for y in range(self.height) for x in range(self.width)
            ]
        }


    def _construir_estado_inicial(self):
        """Construye estado_inicial con puertas, entradas, tripulación, etc."""
        # Mapeo de direcciones
        DIR = {'N': 'norte', 'S': 'sur', 'E': 'este', 'O': 'oeste'}

        # Buscar puertas cerradas (evitar duplicados)
        puertas_vistas = set()
        puertas = []
        for (x, y), celda in self.cells.items():
            for d, pared in celda.walls.items():
                if pared.door == 1:
                    # Crear identificador único para la puerta
                    if d == 'N':
                        puerta_id = (x, y, 'N')
                    elif d == 'S':
                        puerta_id = (x, y+1, 'N')
                    elif d == 'E':
                        puerta_id = (x, y, 'E')
                    elif d == 'O':
                        puerta_id = (x-1, y, 'E')
                    else:
                        puerta_id = (x, y, d)
                    
                    if puerta_id not in puertas_vistas:
                        puertas_vistas.add(puerta_id)
                        puertas.append({
                            "fila": y + 1, "columna": x + 1,
                            "direccion": DIR.get(d, d), "abierta": False
                        })

        # Entradas con dirección
        entradas = []
        for x, y in self.entradas:
            if y == 0: dire = "norte"
            elif y == self.height - 1: dire = "sur"
            elif x == 0: dire = "oeste"
            else: dire = "este"
            entradas.append({"fila": y + 1, "columna": x + 1, "direccion": dire})

        # Tripulación inicial
        tripulacion = []
        for i, a in enumerate(self.astronautas):
            ent = self.entradas[i % len(self.entradas)] if self.entradas else (0, 0)
            tripulacion.append({
                "id": a.unique_id + 1, "tipo": "jugador",
                "fila": ent[1] + 1, "columna": ent[0] + 1,
                "puntos_accion": 4, "cargando_victima": False
            })

        # POIs iniciales (sin revelar)
        puntos_interes = []
        poi_id = 1
        for (x, y), celda in self.cells.items():
            if celda.poi > 0:
                tipo = "victima" if celda.poi == 1 else "falsa_alarma"
                puntos_interes.append({
                    "id": poi_id,
                    "fila": y + 1, "columna": x + 1,
                    "revelado": celda.poi_revelado,
                    "tipo": tipo
                })
                poi_id += 1

        # Arañas iniciales (fuego)
        aranas = []
        for (x, y), celda in self.cells.items():
            if celda.fire:
                aranas.append({"fila": y + 1, "columna": x + 1})

        # Huevos iniciales (humo)
        huevos = []
        for (x, y), celda in self.cells.items():
            if celda.smoke:
                huevos.append({"fila": y + 1, "columna": x + 1})

        return {
            "tripulacion": tripulacion,
            "puntosInteres": puntos_interes,
            "arañas": aranas,
            "huevos": huevos,
            "puertas": puertas,
            "entradas": entradas,
            "contador_colapso_edificio": 0
        }


    def _construir_turno(self, turno_data):
        """
        Construye un turno completo intercalando acciones y dados.
        Formato CORRECTO: [acción jugador 0, dado 0, acción jugador 1, dado 1, ...]
        
        Orden REAL de ejecución en Python:
        - Jugador 0 actúa → Dado 0 se lanza
        - Jugador 1 actúa → Dado 1 se lanza
        - ...
        """
        estado = turno_data.get("estado", {})
        es_final = turno_data["turno"] == self.turn
        
        acciones_raw = turno_data.get("acciones", [])
        dados_raw = turno_data.get("dados", [])
        
        # Agrupar acciones por jugador (asumiendo que vienen en orden)
        acciones_por_jugador = []
        jugador_actual = None
        grupo_actual = []
        
        for accion in acciones_raw:
            jugador_id = accion.get("agente_id")
            if jugador_id != jugador_actual:
                if grupo_actual:
                    acciones_por_jugador.append(grupo_actual)
                jugador_actual = jugador_id
                grupo_actual = [accion]
            else:
                grupo_actual.append(accion)
        
        if grupo_actual:
            acciones_por_jugador.append(grupo_actual)
        
        # Crear secuencia intercalada en el ORDEN CORRECTO
        # IMPORTANTE: Cada agente actúa ANTES de que se lance su dado correspondiente
        secuencias = []
        num_jugadores = len(acciones_por_jugador)
        num_dados = len(dados_raw)
        
        for i in range(num_jugadores):
            # PRIMERO: Agregar acciones del jugador i (si existen)
            if i < num_jugadores:
                secuencias.append({
                    "tipo": "acciones_jugador",
                    "jugador_id": acciones_por_jugador[i][0].get("agente_id"),
                    "acciones": [self._convertir_accion(a) for a in acciones_por_jugador[i]]
                })
            
            # DESPUÉS: Agregar tirada de dado i (si existe)
            # Nota: Puede haber menos dados que jugadores si el juego termina anticipadamente
            if i < num_dados:
                secuencias.append({
                    "tipo": "tirada_dado",
                    "tirada": self._convertir_tirada(dados_raw[i])
                })
        
        return {
            "numero_turno": turno_data["turno"],
            "secuencia": secuencias,  # Secuencia CORRECTA: acciones → dados
            "estado_juego": {
                "victimas_rescatadas": estado.get("rescatadas", 0),
                "victimas_perdidas": estado.get("perdidas", 0),
                "falsas_alarmas": 0,
                "daño_edificio": estado.get("dano", 0),
                "juego_terminado": self.juego_terminado if es_final else False,
                "resultado": self._resultado_str() if es_final else "en_progreso",
                "mensaje": self._mensaje_turno(turno_data)
            }
        }


    def _convertir_tirada(self, dado):
        """Convierte una tirada de dados"""
        # Mapeo de estados: fuego->araña, humo->huevo
        ESTADO = {"fuego": "araña", "humo": "huevo", "vacio": "vacio",
                  "fuera": "fuera", "explosion": "explosion", "araña": "araña"}
        DIR = {'N': 'norte', 'S': 'sur', 'E': 'este', 'O': 'oeste'}

        cambios_orig = dado.get("cambios", {})
        cambios = {}
        
        # Obtener la posición de la tirada (donde ocurre la explosión)
        fila_explosion = dado.get("fila", 0)
        columna_explosion = dado.get("columna", 0)

        # Detectar si es una explosión (araña -> araña con cambios de explosión)
        es_explosion = cambios_orig.get("es_explosion", False)
        
        # Convertir paredes dañadas - INCLUIR fila y columna de la explosión
        if cambios_orig.get("paredes_danadas"):
            cambios["paredes_dañadas"] = [{
                "fila": fila_explosion,
                "columna": columna_explosion,
                "direccion": DIR.get(p.get("dir"), p.get("dir")),
                "nivel_dano": p.get("dano", p.get("estado", 1))
            } for p in cambios_orig["paredes_danadas"]]

        # Convertir fuego_propagado -> arañas_nuevas
        if cambios_orig.get("fuego_propagado"):
            cambios["arañas_nuevas"] = [
                {"fila": pos[1] + 1, "columna": pos[0] + 1}
                for pos in cambios_orig["fuego_propagado"]
            ]

        # Marcar si es explosión para que Unity sepa mostrar el efecto
        if es_explosion:
            cambios["tipo_evento"] = "explosion"

        # Huevos removidos (humo que se volvió fuego)
        ant = dado.get("estado_anterior", "")
        nuevo = dado.get("estado_nuevo", "")
        if ant == "humo" and nuevo == "araña":
            cambios["huevos_removidos"] = [{"fila": dado["fila"], "columna": dado["columna"]}]
            if "arañas_nuevas" not in cambios:
                cambios["arañas_nuevas"] = []
            cambios["arañas_nuevas"].append({"fila": dado["fila"], "columna": dado["columna"]})

        # Huevos nuevos (vacio que se volvió humo)
        if ant == "vacio" and nuevo == "huevo":
            cambios["huevos_nuevos"] = [{"fila": dado["fila"], "columna": dado["columna"]}]

        return {
            "fila": dado.get("fila", 0),
            "columna": dado.get("columna", 0),
            "estado_anterior": ESTADO.get(ant, ant),
            "estado_nuevo": ESTADO.get(nuevo, nuevo),
            "cambios": cambios
        }


    def _convertir_accion(self, accion):
        """Convierte una acción al formato del ejemplo"""
        # Mapeo de tipos de acción
        TIPO = {
            "extinguir_fuego": "eliminar_araña",
            "extinguir_humo": "eliminar_huevo"
        }

        tipo = accion.get("tipo", "")
        resultado = {
            "tripulacion_id": accion.get("tripulacion_id"),
            "tipo": TIPO.get(tipo, tipo),
            "desde": accion.get("desde"),
            "hacia": accion.get("hacia"),
            "costo_ap": accion.get("costo_ap", 0),
            "cambios": {}
        }

        # Agregar campos extra según tipo
        if tipo == "extinguir_fuego":
            resultado["cambios"] = {"arañas_removidas": [accion.get("hacia")]}

        elif tipo == "extinguir_humo":
            resultado["cambios"] = {"huevos_removidos": [accion.get("hacia")]}

        elif tipo == "revelar_poi":
            res = accion.get("cambios", {}).get("resultado", "victima")
            resultado["resultado"] = res
            resultado["cambios"] = {"pois_revelados": [{"tipo": res}]}

        elif tipo == "depositar_victima":
            resultado["resultado"] = "rescatada"

        elif tipo == "abrir_puerta":
            desde = accion.get("desde", {})
            hacia = accion.get("hacia", {})
            # Calcular dirección
            df, dc = desde.get("fila", 0), desde.get("columna", 0)
            hf, hc = hacia.get("fila", 0), hacia.get("columna", 0)
            dire = "sur" if hf > df else "norte" if hf < df else "este" if hc > dc else "oeste"
            resultado["cambios"] = {"puertas_abiertas": [{"fila": df, "columna": dc, "direccion": dire}]}

        return resultado


    def _resultado_str(self):
        """Convierte resultado a string simple"""
        if not self.resultado:
            return "en_progreso"
        return "victoria" if "VICTORIA" in self.resultado.upper() else "derrota"


    def _mensaje_turno(self, turno_data):
        """Genera mensaje resumen del turno"""
        logs = turno_data.get("logs", [])
        num = turno_data["turno"]

        # Buscar eventos importantes
        for log in logs:
            if "EXPLOSION" in log.upper():
                return f"Turno {num}: ¡EXPLOSIÓN!"
            if "VICTIMA RESCATADA" in log.upper():
                return f"Turno {num}: Víctima rescatada"
            if "VICTIMA PERDIDA" in log.upper():
                return f"Turno {num}: Víctima perdida"

        return f"Turno {num}: Acciones normales"

"""# Mapa"""

import numpy as np
from mesa import Agent, Model
from mesa.space import MultiGrid
from typing import Optional, Tuple
import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
import heapq
import json
from mesa.datacollection import DataCollector
import pandas as pd

MAPA_EJEMPLO = """
1100 1000 1001 1100 1001 1100 1000 1001
0100 0000 0011 0110 0011 0110 0010 0011
0100 0001 1100 1000 1000 1001 1100 1001
0110 0011 0110 0010 0010 0011 0110 0011
1100 1000 1000 1000 1001 1100 1001 1101
0110 0010 0010 0010 0011 0110 0011 0111
2 4 f
5 1 v
5 8 v
2 2
2 3
3 2
3 3
3 4
3 5
4 4
5 6
5 7
6 6
1 3 1 4
2 5 2 6
3 2 3 3
2 8 3 8
4 6 4 7
4 4 5 4
6 5 6 6
6 7 6 8
3 1
1 6
4 8
6 3
"""

if __name__ == "__main__":
    random.seed(42)
    print("="*50 + "\n FLASH POINT: FIRE RESCUE\n" + "="*50)
    
    # Crear archivo de log detallado
    log_file = open("simulacion_detallada.txt", "w", encoding='utf-8')
    log_file.write("="*80 + "\n")
    log_file.write("FLASH POINT: FIRE RESCUE - SIMULACIÓN DETALLADA\n")
    log_file.write("="*80 + "\n\n")
    
    model = Nave(num_agents=6, mapa_texto=MAPA_EJEMPLO, estrategia="inteligente")
    
    # Guardar estado inicial en el log
    log_file.write("\n" + "="*80 + "\n")
    log_file.write("ESTADO INICIAL\n")
    log_file.write("="*80 + "\n")
    log_file.write(f"Dimensiones: {model.width}x{model.height}\n")
    log_file.write(f"Agentes: {len(model.astronautas)}\n")
    log_file.write(f"Estrategia: {model.estrategia}\n")
    log_file.write(f"Entradas: {model.entradas}\n")
    log_file.write(f"Salidas: {model.salidas}\n\n")
    
    # Guardar posiciones iniciales de POIs
    log_file.write("POIs iniciales:\n")
    for (x, y), celda in model.cells.items():
        if celda.poi > 0:
            tipo = "VICTIMA" if celda.poi == 1 else "FALSA ALARMA"
            log_file.write(f"  - Posición ({x}, {y}): {tipo}\n")
    
    # Guardar fuegos iniciales
    log_file.write("\nFuegos iniciales:\n")
    for (x, y), celda in model.cells.items():
        if celda.fire:
            log_file.write(f"  - Posición ({x}, {y})\n")
    
    log_file.write("\n")
    
    # Ejecutar simulación
    for turno in range(20):
        if not model.ejecutar_turno(): 
            break
        
        # Guardar todos los logs del turno en el archivo
        log_file.write("\n" + "="*80 + "\n")
        log_file.write(f"TURNO {model.turn} - RESUMEN\n")
        log_file.write("="*80 + "\n")
        
        # Escribir todos los logs del turno actual
        for log_msg in model._logs_turno_actual:
            log_file.write(log_msg + "\n")
        
        # Estado al final del turno
        log_file.write("\n--- ESTADO AL FINAL DEL TURNO ---\n")
        log_file.write(f"Víctimas rescatadas: {model.victims_rescued}/7\n")
        log_file.write(f"Víctimas perdidas: {model.victims_lost}/4\n")
        log_file.write(f"Daño estructural: {model.damage_counter}/24\n")
        log_file.write(f"Explosiones totales: {model.total_explosions}\n")
        log_file.write(f"Flashovers totales: {model.total_flashovers}\n")
        
        # Posición de agentes
        log_file.write("\nPosición de agentes:\n")
        for a in model.astronautas:
            if a.alive:
                victima_str = " [CARGANDO VÍCTIMA]" if a.cargando_victima else ""
                log_file.write(f"  Agente {a.unique_id}: ({a.x}, {a.y}) - AP: {a.ap}{victima_str}\n")
            else:
                log_file.write(f"  Agente {a.unique_id}: FUERA DE JUEGO\n")
        
        log_file.write("\n")
    
    # Resultado final
    log_file.write("\n" + "="*80 + "\n")
    log_file.write("RESULTADO FINAL\n")
    log_file.write("="*80 + "\n")
    log_file.write(f"Resultado: {model.resultado}\n")
    log_file.write(f"Turnos jugados: {model.turn}\n")
    log_file.write(f"Víctimas rescatadas: {model.victims_rescued}/7\n")
    log_file.write(f"Víctimas perdidas: {model.victims_lost}/4\n")
    log_file.write(f"Daño estructural: {model.damage_counter}/24\n")
    log_file.write(f"Explosiones totales: {model.total_explosions}\n")
    log_file.write(f"Flashovers totales: {model.total_flashovers}\n")
    
    # Estadísticas por agente
    log_file.write("\n--- ESTADÍSTICAS POR AGENTE ---\n")
    for a in model.astronautas:
        log_file.write(f"\nAgente {a.unique_id}:\n")
        log_file.write(f"  - Fuegos apagados: {a.fires_extinguished}\n")
        log_file.write(f"  - Humos apagados: {a.smoke_extinguished}\n")
        log_file.write(f"  - POIs revelados: {a.pois_revealed}\n")
        log_file.write(f"  - Víctimas cargadas: {a.victims_carried}\n")
        log_file.write(f"  - Knockdowns: {a.knockdowns}\n")
        log_file.write(f"  - Estado: {'VIVO' if a.alive else 'FUERA DE JUEGO'}\n")
    
    log_file.write("\n" + "="*80 + "\n")
    log_file.close()
    
    # Guardar JSON
    with open("simulacion.json", "w", encoding='utf-8') as f: 
        json_content = model.generar_json_formato_ejemplo()
        f.write(json_content)
    
    # Guardar copia del JSON con formato legible
    with open("simulacion_legible.json", "w", encoding='utf-8') as f:
        json_data = json.loads(json_content)
        f.write(json.dumps(json_data, indent=2, ensure_ascii=False))
    
    print(f"\n[OK] JSON guardado (formato Unity) | Resultado: {model.resultado}")
    print(f"[OK] Log detallado guardado en: simulacion_detallada.txt")
    print(f"[OK] JSON legible guardado en: simulacion_legible.json")

    # Call the new export method
    model.exportar_stats_csv()

"""# Animación
Vuelve a correr el model y crea una animación
"""

from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import copy

def capturar_estados(num_turnos=20):
    """
    Ejecuta la simulación y captura cada estado intermedio
    (cada movimiento individual de los agentes)
    """
    random.seed(51)
    model = Nave(width=8, height=6, num_agents=6, mapa_texto=MAPA_EJEMPLO)

    estados = []

    # Capturar estado inicial
    estados.append({
        'descripcion': 'Estado Inicial',
        'celda_data': {pos: _copiar_celda(c) for pos, c in model.cells.items()},
        'agentes': [_copiar_agente(a) for a in model.astronautas],
        'turno': 0,
        'rescatadas': 0,
        'perdidas': 0,
        'dano': 0,
        'explosiones': 0,
        'flashovers': 0,
        'salidas': model.salidas.copy(),
        'juego_terminado': False,
        'resultado': None
    })

    # Modificar agentes para capturar estados
    original_mover = AstronautAgent._mover
    original_extinguir = AstronautAgent._extinguir
    original_revelar = AstronautAgent._revelar_poi
    original_cargar = AstronautAgent._cargar_victima
    original_soltar = AstronautAgent.soltarVictima

    def mover_con_captura(self, direccion):
        result = original_mover(self, direccion)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} se movió")
        return result

    def extinguir_con_captura(self, celda):
        result = original_extinguir(self, celda)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} extinguió fuego/humo")
        return result

    def revelar_con_captura(self, celda):
        result = original_revelar(self, celda)
        _capturar_estado(model, estados, f"Agent {self.unique_id} reveló POI")
        return result

    def cargar_con_captura(self):
        result = original_cargar(self)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} cargó víctima")
        return result

    def soltar_con_captura(self):
        result = original_soltar(self)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} rescató víctima!")
        return result

    # Aplicar monkey patching
    AstronautAgent._mover = mover_con_captura
    AstronautAgent._extinguir = extinguir_con_captura
    AstronautAgent._revelar_poi = revelar_con_captura
    AstronautAgent._cargar_victima = cargar_con_captura
    AstronautAgent.soltarVictima = soltar_con_captura

    # Ejecutar simulación
    for i in range(num_turnos):
        if model.juego_terminado:
            break

        # Capturar inicio de turno
        _capturar_estado(model, estados, f"=== INICIO TURNO {model.turn + 1} ===")

        # Ejecutar turno (esto capturará estados intermedios)
        model.ejecutar_turno()

        # Capturar fin de turno (después de avance de fuego)
        _capturar_estado(model, estados, f"=== FIN TURNO {model.turn} ===")

    # Restaurar métodos originales
    AstronautAgent._mover = original_mover
    AstronautAgent._extinguir = original_extinguir
    AstronautAgent._revelar_poi = original_revelar
    AstronautAgent._cargar_victima = original_cargar
    AstronautAgent.soltarVictima = original_soltar

    return estados, model

def _copiar_celda(celda):
    """Crea una copia de los datos relevantes de una celda"""
    return {
        'fire': celda.fire,
        'smoke': celda.smoke,
        'poi': celda.poi,
        'poi_revelado': celda.poi_revelado,
        'walls': {d: {'enPie': w.enPie, 'door': w.door, 'damage': w.damage}
                  for d, w in celda.walls.items()}
    }

def _copiar_agente(agente):
    """Crea una copia de los datos relevantes de un agente"""
    return {
        'id': agente.unique_id,
        'x': agente.x,
        'y': agente.y,
        'ap': agente.ap,
        'alive': agente.alive,
        'cargando_victima': agente.cargando_victima,
        'knockdowns': agente.knockdowns
    }

def _capturar_estado(model, estados, descripcion):
    """Captura el estado actual del modelo"""
    estados.append({
        'descripcion': descripcion,
        'celda_data': {pos: _copiar_celda(c) for pos, c in model.cells.items()},
        'agentes': [_copiar_agente(a) for a in model.astronautas],
        'turno': model.turn,
        'rescatadas': model.victims_rescued,
        'perdidas': model.victims_lost,
        'dano': model.damage_counter,
        'explosiones': model.total_explosions,
        'flashovers': model.total_flashovers,
        'salidas': model.salidas.copy(),
        'juego_terminado': model.juego_terminado,
        'resultado': model.resultado
    })

def crear_animacion_detallada(estados, intervalo=500):
    """
    Crea una animación frame por frame de los estados capturados
    """
    fig, ax = plt.subplots(figsize=(14, 10))
    fig.patch.set_facecolor('#0a0a1a')

    def update(frame_idx):
        if frame_idx >= len(estados):
            return []

        estado = estados[frame_idx]
        visualizar_estado(ax, estado, frame_idx)
        return []

    def visualizar_estado(ax, estado, frame_num):
        """Dibuja un estado específico del tablero"""
        ax.clear()
        ax.set_xlim(-0.5, 8.5)
        ax.set_ylim(-0.5, 6.5)
        ax.set_aspect('equal')
        ax.invert_yaxis()
        ax.set_facecolor('#1a1a2e')

        # Dibujar celdas
        for pos, celda_data in estado['celda_data'].items():
            x, y = pos

            # Color según estado
            if celda_data['fire']:
                color = '#ff4444'
                alpha = 0.9
            elif celda_data['smoke']:
                color = '#666666'
                alpha = 0.7
            else:
                color = '#3d3d5c'
                alpha = 0.5

            rect = patches.Rectangle(
                (x, y), 1, 1,
                facecolor=color,
                edgecolor='#555',
                linewidth=1,
                alpha=alpha
            )
            ax.add_patch(rect)

            # Mostrar POI
            if celda_data['poi'] > 0:
                if not celda_data['poi_revelado']:
                    marker = '?'
                    color_poi = '#ffff00'
                    size = 20
                elif celda_data['poi'] == 1:
                    marker = 'V'
                    color_poi = '#00ff00'
                    size = 22
                else:
                    marker = 'X'
                    color_poi = '#ff8800'
                    size = 18

                ax.text(
                    x + 0.5, y + 0.5, marker,
                    ha='center', va='center',
                    fontsize=size,
                    color=color_poi,
                    weight='bold',
                    bbox=dict(boxstyle='circle', facecolor='black', alpha=0.3)
                )

        # Dibujar paredes
        for pos, celda_data in estado['celda_data'].items():
            x, y = pos
            for dir_name, wall_data in celda_data['walls'].items():
                if not wall_data['enPie'] or wall_data['damage'] >= 2:
                    continue

                if wall_data['door'] == 1:
                    color_p = '#FFD700'
                    width = 5
                    style = '--'
                elif wall_data['door'] == 2:
                    color_p = '#00FF00'
                    width = 3
                    style = ':'
                else:
                    if wall_data['damage'] == 0:
                        color_p = '#ffffff'
                        width = 4
                    elif wall_data['damage'] == 1:
                        color_p = '#ff8800'
                        width = 3
                    else:
                        continue
                    style = '-'

                if dir_name == 'N':
                    ax.plot([x, x+1], [y, y], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'S':
                    ax.plot([x, x+1], [y+1, y+1], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'O':
                    ax.plot([x, x], [y, y+1], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'E':
                    ax.plot([x+1, x+1], [y, y+1], color=color_p, linewidth=width, linestyle=style)

        # Dibujar agentes
        for agente_data in estado['agentes']:
            if not agente_data['alive']:
                ax.plot(
                    agente_data['x'] + 0.5, agente_data['y'] + 0.5,
                    'x', markersize=15,
                    color='red',
                    markeredgewidth=3
                )
                continue

            if agente_data['cargando_victima']:
                color_a = '#FF00FF'
            else:
                color_a = '#00FFFF'

            circle = patches.Circle(
                (agente_data['x'] + 0.5, agente_data['y'] + 0.5),
                0.35,
                facecolor=color_a,
                edgecolor='#ffffff',
                linewidth=3
            )
            ax.add_patch(circle)

            ax.text(
                agente_data['x'] + 0.5, agente_data['y'] + 0.5,
                str(agente_data['id']),
                ha='center', va='center',
                fontsize=14,
                color='black',
                weight='bold'
            )

            ax.text(
                agente_data['x'] + 0.5, agente_data['y'] + 0.85,
                f'{agente_data["ap"]}AP',
                ha='center', va='top',
                fontsize=8,
                color='white',
                bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7)
            )

        # Dibujar salidas
        for (sx, sy) in estado['salidas']:
            triangle = patches.RegularPolygon(
                (sx + 0.5, sy + 0.5),
                3,
                radius=0.3,
                orientation=0,
                facecolor='#00ff00',
                edgecolor='white',
                linewidth=2
            )
            ax.add_patch(triangle)
            ax.text(
                sx + 0.5, sy + 0.2,
                'EXIT',
                ha='center', va='center',
                fontsize=6,
                color='white',
                weight='bold'
            )

        # Información
        info_text = (
            f'TURNO: {estado["turno"]} | '
            f'RESCATADAS: {estado["rescatadas"]}/7 | '
            f'PERDIDAS: {estado["perdidas"]}/4 | '
            f'DAÑO: {estado["dano"]}/24\n'
            f'Explosiones: {estado["explosiones"]} | '
            f'Flashovers: {estado["flashovers"]}\n'
            f'Frame {frame_num}/{len(estados)-1}: {estado["descripcion"]}'
        )

        if estado['juego_terminado']:
            info_text += f'\n\n*** {estado["resultado"]} ***'

        ax.set_title(
            info_text,
            fontsize=11,
            color='white',
            weight='bold',
            pad=20,
            bbox=dict(boxstyle='round,pad=0.8', facecolor='#0a0a1a', alpha=0.8)
        )

        ax.grid(True, alpha=0.3, color='#555555', linestyle=':')
        ax.set_xticks(range(9))
        ax.set_yticks(range(7))

        # Leyenda
        legend_elements = [
            patches.Patch(facecolor='#ff4444', label='Fuego'),
            patches.Patch(facecolor='#666666', label='Humo'),
            patches.Patch(facecolor='#00FFFF', label='Agente'),
            patches.Patch(facecolor='#FF00FF', label='Con víctima'),
            patches.Patch(facecolor='#ffff00', label='POI ?'),
            patches.Patch(facecolor='#00ff00', label='Víctima'),
        ]
        ax.legend(
            handles=legend_elements,
            loc='upper left',
            bbox_to_anchor=(1.02, 1),
            fontsize=9,
            facecolor='#1a1a2e',
            edgecolor='white',
            labelcolor='white'
        )

    anim = FuncAnimation(
        fig,
        update,
        frames=len(estados),
        interval=intervalo,
        repeat=True,
        blit=False
    )

    plt.tight_layout()
    return anim

# ============================================================================
# EJECUTAR ANIMACIÓN DETALLADA
# ============================================================================

print("\n" + "="*60)
print("CAPTURANDO ESTADOS DE LA SIMULACIÓN...")
print("="*60)

# Capturar todos los estados (esto ejecutará la simulación completa)
estados, modelo_final = capturar_estados(num_turnos=20)

print(f"\n[OK] Capturados {len(estados)} estados/frames")
print(f"[OK] Resultado: {modelo_final.resultado if modelo_final.juego_terminado else 'Simulación completa'}")

print("\n" + "="*60)
print("CREANDO ANIMACIÓN INTERACTIVA...")
print("="*60)

# Crear animación con los estados capturados
# intervalo en ms: menor = más rápido (300ms = 0.3s por frame)
anim = crear_animacion_detallada(estados, intervalo=400)

# Mostrar con controles interactivos
display(HTML(anim.to_jshtml()))
plt.close()

print("\n" + "="*60)
print("[OK] ANIMACIÓN LISTA")
print(f"  - Total de frames: {len(estados)}")
print(f"  - Usa los controles para Play/Pause y navegar")
print("="*60)

from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import copy

def capturar_estados(num_turnos=20):
    """
    Ejecuta la simulación y captura cada estado intermedio
    (cada movimiento individual de los agentes)
    """
    random.seed(51)
    model = Nave(width=8, height=6, num_agents=6, mapa_texto=MAPA_EJEMPLO)

    estados = []

    # Capturar estado inicial
    estados.append({
        'descripcion': 'Estado Inicial',
        'celda_data': {pos: _copiar_celda(c) for pos, c in model.cells.items()},
        'agentes': [_copiar_agente(a) for a in model.astronautas],
        'turno': 0,
        'rescatadas': 0,
        'perdidas': 0,
        'dano': 0,
        'explosiones': 0,
        'flashovers': 0,
        'salidas': model.salidas.copy(),
        'juego_terminado': False,
        'resultado': None
    })

    # Modificar agentes para capturar estados
    original_mover = AstronautAgent._mover
    original_extinguir = AstronautAgent._extinguir
    original_revelar = AstronautAgent._revelar_poi
    original_cargar = AstronautAgent._cargar_victima
    original_soltar = AstronautAgent.soltarVictima

    def mover_con_captura(self, direccion):
        result = original_mover(self, direccion)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} se movió")
        return result

    def extinguir_con_captura(self, celda):
        result = original_extinguir(self, celda)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} extinguió fuego/humo")
        return result

    def revelar_con_captura(self, celda):
        result = original_revelar(self, celda)
        _capturar_estado(model, estados, f"Agent {self.unique_id} reveló POI")
        return result

    def cargar_con_captura(self):
        result = original_cargar(self)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} cargó víctima")
        return result

    def soltar_con_captura(self):
        result = original_soltar(self)
        if result:
            _capturar_estado(model, estados, f"Agent {self.unique_id} rescató víctima!")
        return result

    # Aplicar monkey patching
    AstronautAgent._mover = mover_con_captura
    AstronautAgent._extinguir = extinguir_con_captura
    AstronautAgent._revelar_poi = revelar_con_captura
    AstronautAgent._cargar_victima = cargar_con_captura
    AstronautAgent.soltarVictima = soltar_con_captura

    # Ejecutar simulación
    for i in range(num_turnos):
        if model.juego_terminado:
            break

        # Capturar inicio de turno
        _capturar_estado(model, estados, f"=== INICIO TURNO {model.turn + 1} ===")

        # Ejecutar turno (esto capturará estados intermedios)
        model.ejecutar_turno()

        # Capturar fin de turno (después de avance de fuego)
        _capturar_estado(model, estados, f"=== FIN TURNO {model.turn} ===")

    # Restaurar métodos originales
    AstronautAgent._mover = original_mover
    AstronautAgent._extinguir = original_extinguir
    AstronautAgent._revelar_poi = original_revelar
    AstronautAgent._cargar_victima = original_cargar
    AstronautAgent.soltarVictima = original_soltar

    return estados, model

def _copiar_celda(celda):
    """Crea una copia de los datos relevantes de una celda"""
    return {
        'fire': celda.fire,
        'smoke': celda.smoke,
        'poi': celda.poi,
        'poi_revelado': celda.poi_revelado,
        'walls': {d: {'enPie': w.enPie, 'door': w.door, 'damage': w.damage}
                  for d, w in celda.walls.items()}
    }

def _copiar_agente(agente):
    """Crea una copia de los datos relevantes de un agente"""
    return {
        'id': agente.unique_id,
        'x': agente.x,
        'y': agente.y,
        'ap': agente.ap,
        'alive': agente.alive,
        'cargando_victima': agente.cargando_victima,
        'knockdowns': agente.knockdowns,
        'fires_extinguished': agente.fires_extinguished,
        'smoke_extinguished': agente.smoke_extinguished,
        'pois_revealed': agente.pois_revealed,
        'victims_carried': agente.victims_carried
    }

def _capturar_estado(model, estados, descripcion):
    """Captura el estado actual del modelo"""
    estados.append({
        'descripcion': descripcion,
        'celda_data': {pos: _copiar_celda(c) for pos, c in model.cells.items()},
        'agentes': [_copiar_agente(a) for a in model.astronautas],
        'turno': model.turn,
        'rescatadas': model.victims_rescued,
        'perdidas': model.victims_lost,
        'dano': model.damage_counter,
        'explosiones': model.total_explosions,
        'flashovers': model.total_flashovers,
        'salidas': model.salidas.copy(),
        'juego_terminado': model.juego_terminado,
        'resultado': model.resultado
    })

def crear_animacion_detallada(estados, intervalo=500):
    """
    Crea una animación frame por frame de los estados capturados
    """
    fig, ax = plt.subplots(figsize=(14, 10))
    fig.patch.set_facecolor('#0a0a1a')

    def update(frame_idx):
        if frame_idx >= len(estados):
            return []

        estado = estados[frame_idx]
        visualizar_estado(ax, estado, frame_idx)
        return []

    def visualizar_estado(ax, estado, frame_num):
        """Dibuja un estado específico del tablero"""
        ax.clear()
        ax.set_xlim(-0.5, 8.5)
        ax.set_ylim(-0.5, 6.5)
        ax.set_aspect('equal')
        ax.invert_yaxis()
        ax.set_facecolor('#1a1a2e')

        # Dibujar celdas
        for pos, celda_data in estado['celda_data'].items():
            x, y = pos

            # Color según estado
            if celda_data['fire']:
                color = '#ff4444'
                alpha = 0.9
            elif celda_data['smoke']:
                color = '#666666'
                alpha = 0.7
            else:
                color = '#3d3d5c'
                alpha = 0.5

            rect = patches.Rectangle(
                (x, y),
                1, 1,
                facecolor=color,
                edgecolor='#555',
                linewidth=1,
                alpha=alpha
            )
            ax.add_patch(rect)

            # Mostrar POI
            if celda_data['poi'] > 0:
                if not celda_data['poi_revelado']:
                    marker = '?'
                    color_poi = '#ffff00'
                    size = 20
                elif celda_data['poi'] == 1:
                    marker = 'V'
                    color_poi = '#00ff00'
                    size = 22
                else:
                    marker = 'X'
                    color_poi = '#ff8800'
                    size = 18

                ax.text(
                    x + 0.5, y + 0.5,
                    marker,
                    ha='center', va='center',
                    fontsize=size,
                    color=color_poi,
                    weight='bold',
                    bbox=dict(boxstyle='circle', facecolor='black', alpha=0.3)
                )

        # Dibujar paredes
        for pos, celda_data in estado['celda_data'].items():
            x, y = pos
            for dir_name, wall_data in celda_data['walls'].items():
                if not wall_data['enPie'] or wall_data['damage'] >= 2:
                    continue

                if wall_data['door'] == 1:
                    color_p = '#FFD700'
                    width = 5
                    style = '--'
                elif wall_data['door'] == 2:
                    color_p = '#00FF00'
                    width = 3
                    style = ':'
                else:
                    if wall_data['damage'] == 0:
                        color_p = '#ffffff'
                        width = 4
                    elif wall_data['damage'] == 1:
                        color_p = '#ff8800'
                        width = 3
                    else:
                        continue
                    style = '-'

                if dir_name == 'N':
                    ax.plot([x, x+1], [y, y], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'S':
                    ax.plot([x, x+1], [y+1, y+1], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'O':
                    ax.plot([x, x], [y, y+1], color=color_p, linewidth=width, linestyle=style)
                elif dir_name == 'E':
                    ax.plot([x+1, x+1], [y, y+1], color=color_p, linewidth=width, linestyle=style)

        # Dibujar agentes
        for agente_data in estado['agentes']:
            if not agente_data['alive']:
                ax.plot(
                    agente_data['x'] + 0.5, agente_data['y'] + 0.5,
                    'x', markersize=15,
                    color='red',
                    markeredgewidth=3
                )
                continue

            if agente_data['cargando_victima']:
                color_a = '#FF00FF'
            else:
                color_a = '#00FFFF'

            circle = patches.Circle(
                (agente_data['x'] + 0.5, agente_data['y'] + 0.5),
                0.35,
                facecolor=color_a,
                edgecolor='#ffffff',
                linewidth=3
            )
            ax.add_patch(circle)

            ax.text(
                agente_data['x'] + 0.5, agente_data['y'] + 0.5,
                str(agente_data['id']),
                ha='center', va='center',
                fontsize=14,
                color='black',
                weight='bold'
            )

            # Display AP
            ax.text(
                agente_data['x'] + 0.5, agente_data['y'] + 0.85,
                f'{agente_data["ap"]}AP',
                ha='center', va='top',
                fontsize=8,
                color='white',
                bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7)
            )

            # Display accumulated stats (fires_extinguished, smoke_extinguished, pois_revealed, victims_carried)
            stats_text = (
                f'F:{agente_data["fires_extinguished"]} S:{agente_data["smoke_extinguished"]}\n'
                f'P:{agente_data["pois_revealed"]} V:{agente_data["victims_carried"]}'
            )
            ax.text(
                agente_data['x'] + 0.5, agente_data['y'] + 0.15, # Adjusted y position to avoid overlap
                stats_text,
                ha='center', va='bottom',
                fontsize=7,
                color='white',
                bbox=dict(boxstyle='round,pad=0.2', facecolor='black', alpha=0.6)
            )


        # Dibujar salidas
        for (sx, sy) in estado['salidas']:
            triangle = patches.RegularPolygon(
                (sx + 0.5, sy + 0.5),
                3,
                radius=0.3,
                orientation=0,
                facecolor='#00ff00',
                edgecolor='white',
                linewidth=2
            )
            ax.add_patch(triangle)
            ax.text(
                sx + 0.5, sy + 0.2,
                'EXIT',
                ha='center', va='center',
                fontsize=6,
                color='white',
                weight='bold'
            )

        # Información
        info_text = (
            f'TURNO: {estado["turno"]} | '
            f'RESCATADAS: {estado["rescatadas"]}/7 | '
            f'PERDIDAS: {estado["perdidas"]}/4 | '
            f'DAÑO: {estado["dano"]}/24\n'
            f'Explosiones: {estado["explosiones"]} | '
            f'Flashovers: {estado["flashovers"]}\n'
            f'Frame {frame_num}/{len(estados)-1}: {estado["descripcion"]}'
        )

        if estado['juego_terminado']:
            info_text += f'\n\n*** {estado["resultado"]} ***'

        ax.set_title(
            info_text,
            fontsize=11,
            color='white',
            weight='bold',
            pad=20,
            bbox=dict(boxstyle='round,pad=0.8', facecolor='#0a0a1a', alpha=0.8)
        )

        ax.grid(True, alpha=0.3, color='#555555', linestyle=':')
        ax.set_xticks(range(9))
        ax.set_yticks(range(7))

        # Leyenda
        legend_elements = [
            patches.Patch(facecolor='#ff4444', label='Fuego'),
            patches.Patch(facecolor='#666666', label='Humo'),
            patches.Patch(facecolor='#00FFFF', label='Agente'),
            patches.Patch(facecolor='#FF00FF', label='Con víctima'),
            patches.Patch(facecolor='#ffff00', label='POI ?'),
            patches.Patch(facecolor='#00ff00', label='Víctima'),
        ]
        ax.legend(
            handles=legend_elements,
            loc='upper left',
            bbox_to_anchor=(1.02, 1),
            fontsize=9,
            facecolor='#1a1a2e',
            edgecolor='white',
            labelcolor='white'
        )

    anim = FuncAnimation(
        fig,
        update,
        frames=len(estados),
        interval=intervalo,
        repeat=True,
        blit=False
    )

    plt.tight_layout()
    return anim

# ============================================================================
# EJECUTAR ANIMACIÓN DETALLADA
# ============================================================================

print("\n" + "="*60)
print("CAPTURANDO ESTADOS DE LA SIMULACIÓN...")
print("="*60)

# Capturar todos los estados (esto ejecutará la simulación completa)
estados, modelo_final = capturar_estados(num_turnos=20)

print(f"\n[OK] Capturados {len(estados)} estados/frames")
print(f"[OK] Resultado: {modelo_final.resultado if modelo_final.juego_terminado else 'Simulacion completa'}")

print("\n" + "="*60)
print("CREANDO ANIMACIÓN INTERACTIVA...")
print("="*60)

# Crear animación con los estados capturados
# intervalo en ms: menor = más rápido (300ms = 0.3s por frame)
anim = crear_animacion_detallada(estados, intervalo=400)

# Mostrar con controles interactivos
display(HTML(anim.to_jshtml()))
plt.close()

print("\n" + "="*60)
print("[OK] ANIMACION LISTA")
print(f"  - Total de frames: {len(estados)}")
print(f"  - Usa los controles para Play/Pause y navegar")
print("="*60)

# Call the new export method to save DataCollector stats
modelo_final.exportar_stats_csv()
# TC2008B Modelación de Sistemas Multiagentes con gráficas computacionales
# Python server to interact with Unity via POST
# Sergio Ruiz-Loza, Ph.D. March 2021

from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import json
import os

class Server(BaseHTTPRequestHandler):
    
    def _set_response(self, content_type='text/html'):
        self.send_response(200)
        # Agregar charset UTF-8 para JSON
        if content_type == 'application/json':
            content_type = 'application/json; charset=utf-8'
        self.send_header('Content-type', content_type)
        self.end_headers()
        
    def do_GET(self):
        # Endpoint para obtener el JSON completo de la simulación
        if self.path == '/simulation_data':
            json_file_path = "simulacion.json"
            if os.path.exists(json_file_path):
                try:
                    # Intentar múltiples encodings como fallback
                    json_content = None
                    for encoding in ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']:
                        try:
                            with open(json_file_path, 'r', encoding=encoding) as f:
                                json_content = f.read()
                            logging.info(f"Successfully read {json_file_path} with encoding: {encoding}")
                            break
                        except (UnicodeDecodeError, UnicodeError):
                            continue
                    
                    if json_content is None:
                        raise Exception("Could not decode file with any supported encoding")
                    
                    self._set_response(content_type='application/json')
                    self.wfile.write(json_content.encode('utf-8'))
                    logging.info(f"Sent {json_file_path} successfully via GET /simulation_data.")
                except Exception as e:
                    logging.error(f"Error reading or sending {json_file_path}: {e}")
                    self._set_response(content_type='text/plain')
                    self.wfile.write(f"Error: Could not read {json_file_path}. {e}".encode('utf-8'))
            else:
                logging.warning(f"File not found: {json_file_path}")
                self._set_response(content_type='text/plain')
                self.wfile.write(f"Error: File {json_file_path} not found.".encode('utf-8'))
        else:
            # Comportamiento GET por defecto si no es /simulation_data
            self._set_response()
            self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))

    def do_POST(self):
        # Define the path to the JSON file
        json_file_path = "simulacion.json"

        # Check if the file exists
        if os.path.exists(json_file_path):
            try:
                # Intentar múltiples encodings como fallback
                json_content = None
                for encoding in ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']:
                    try:
                        with open(json_file_path, 'r', encoding=encoding) as f:
                            json_content = f.read()
                        logging.info(f"Successfully read {json_file_path} with encoding: {encoding}")
                        break
                    except (UnicodeDecodeError, UnicodeError):
                        continue
                
                if json_content is None:
                    raise Exception("Could not decode file with any supported encoding")
                
                self._set_response(content_type='application/json')
                self.wfile.write(json_content.encode('utf-8'))
                logging.info(f"Sent {json_file_path} successfully via POST to {self.path}.")

            except Exception as e:
                logging.error(f"Error reading or sending {json_file_path}: {e}")
                self._set_response(content_type='text/plain')
                self.wfile.write(f"Error: Could not read {json_file_path}. {e}".encode('utf-8'))
        else:
            logging.warning(f"File not found: {json_file_path}")
            self._set_response(content_type='text/plain')
            self.wfile.write(f"Error: File {json_file_path} not found.".encode('utf-8'))


def run(server_class=HTTPServer, handler_class=Server, port=8585):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info("Starting httpd...\n") # HTTPD is HTTP Daemon!
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:   # CTRL+C stops the server
        pass
    httpd.server_close()
    logging.info("Stopping httpd...\n")

if __name__ == '__main__':
    from sys import argv
    
    DEFAULT_PORT = 8585 # Define un puerto por defecto aquí

    if len(argv) == 2:
        try:
            run(port=int(argv[1]))
        except ValueError:
            logging.error(f"Invalid port specified: {argv[1]}. Using default port {DEFAULT_PORT}.")
            run(port=DEFAULT_PORT)
    else:
        logging.info(f"No port specified. Using default port {DEFAULT_PORT}.")
        run(port=DEFAULT_PORT)

